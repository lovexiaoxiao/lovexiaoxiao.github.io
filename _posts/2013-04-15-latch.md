---
layout: post
title: "latch"
description: ""
category: 
tags: []
---
{% include JB/setup %}
6. 锁   
===

## 什么是锁？  

锁机制用于管理对共享资源的并发访问。注意：这里说的是“共享资源”而不是“数据行”。   
例如，执行一个存储过程时，过程本身会以某种模式锁定，以允许其他用户执行这个存储过程，但是不允许另外的用户以任何方式修改这个过程。  
数据库中使用锁是为了支持对共享资源进行并发访问，与此同时还能提供数据完整性和一致性。   

如果有多个用户需要同时访问和修改数据或者数据结构，就要有一种机制来防止对同一份信息的并发修改，这一点至关重要。这正是锁定所要做的全部工作。   

所有数据本质上都不同。学习每一个新数据库时，应该假设自己从来未使用过数据库。   

在Oracle中，你会了解到: 

1. 事物是每个数据库的核心，他们是“好东西”。   
2. 应该延迟到适当时刻才提交。   
3. 只要需要，就应该尽可能长时间地对保持对数据所加的锁。  
4. 在Oracle中，行级锁没有相关的开销，根本没有。  
不论你是有1个行锁，还是10000个行锁，专用于锁定这个消息的“资源”数都一样的。   
5. 在Oracle中，锁升级对系统没有任何好处，不会节省任何资源。  
6. 可以同时得到并发性和一致性。  
数据读取器不会被数据写入器阻塞。数据写入器也不会被数据读取阻塞。  
这是Oracle与大多数其他关系数据库之间的的根本区别之一。    


## 锁定问题  

### 丢失更新   

丢失更新是一个经典的数据库问题。示例如下：   

1. 会话1中的一个事务获取（查询）一行数据，放入本地内存，并显示给一个最终用户User1。  
2. 会话2中的另一个事务也获取这一行，但是将数据显示给另一个最终用户User2。   
3. User1使用应用修改了这一行，让应用更新数据库并提交。会话Session1 的事务现在已经执行。  
4. User2也修改这一行，让应用更新数据库并提交。会话Session2的食物现在已经执行。   

这个过程称为**丢失更新**   

之所以会造成这种情况，这是因为应用开发人员编写的此待续是这样的：更新一个特定的字段时，该记录的所有字段都会“刷新”（只是因为更新所有列更容易，这样就不用先得到哪些列已经修改，并且只更新那些修改过的列）。    
**这在GUI自动生成的SQL中很常见。**    

为了保护你的更新不丢失，就必须使用某种锁定策略，共有两中锁定策略：悲观锁定和乐观锁定。   

### 悲观锁定  

悲观锁定仅用于有状态或者有链接环境。也就是说，你的应用与数据库有一条连续的连接，而且至少在事务生存期中只有你一个人使用这条连接。  

悲观锁定在试图更新行之前就将行锁定了。因为很悲观，对于这一行能不能保持未改变很是怀疑。  

### 乐观锁定  

乐观锁定，是把所有锁定都延迟到即将执行更新之前才做。    
换句话说，我们会修改屏幕上的信息而不要锁。我们很乐观，认为数据不会被其他用户修改；因此，会等到最后一刻采取看我们的想法对不对。    

这种锁定方法在所有环境下都行得通，但是采用这种方法，执行更新的用户“失败”的可能性会加大。这说明，这个用户要更新他的数据行时，发现数据已经修改过，所以他必须从头再来。   

如果某些应用使用了悲观锁定，它会在相对较长的时间内上锁，你可能会考虑使用 select for update nowait，以此来验证行是否未被修改，并在即将 update 列之前锁定来避免被另一个会话阻塞。  

实现乐观并发控制的方法有很多种。常用的方法有： 

1. 应用本身存储行的所有“前印象”。  
2. 使用一个特殊的列，这个列由一个数据库触发器或应用程序代码维护，可以告诉我们记录的“版本”。    
3. 使用一个校验和或散列值，这是使用原来的数据计算得出的。  
4. 使用新增的Oracle 10g 特性 ORA_ROWSCN。   

#### 使用版本列的乐观锁定。      
需要一种方法来维护这个值。我们有两个选择:     
1. 可以由应用维护这一列，更新记录时将last_mod列的值设置为systimestamp。     
2. 也可以由触发器/存储过程来维护。  
如果让应用维护last\_mod，这比基于触发器的方法表现的更好，因为触发器会代表Oracle对修改增加额外的处理。   

不能总是依赖于各个应用来维护这个字段，建议把更新逻辑封装到一个存储过程中，而不要让应用直接更新表。  

#### 使用校验和的乐观锁定  

校验和一般使用单向散列函数来实现。单向散列函数只能在一个方向是应用。   
与使用版本列的做法一样，我们可以采用同样的方法使用这些散列值或校验和，只需把从数据库读出数据时得到的散列或校验和值与修改数据前的得到的散列或校验和值进行比较。   

Oracle提供的三种计算散列值(CPU消耗较严重):

1. OWA\_OPT\_LOCK.CHECKSUM --Oracle 8.1.5 以上提供。出现冲突的可能性是1/65536   

2. DBMS\_OBFUSCATION\_TOLLKIT.MD5 -- Oracle 8.1.7 以上提供。出现冲突可能性是1/3.4028E+38     

3. DBMS\_CRYPTO.HASH -- Oracle 10gR1以后提供。 提供SHA-1或者MD5消息摘要。建议使用SHA-1    
dbms\_crypto.hash(utl\_raw.cast\_to\_raw(x.deptno||'/'||x.dname||'/'||x.loc), dbms\_crypto.hash\_sh1);   

#### 使用 ORA_ROWSCN的乐观锁定   
从Oracle 10gR1开始，可以使用内置的ORA_ROWSCN函数。由Oracle自动执行。  
ORA_ROWSCN建立在内部Oracle系统时钟（SCN）基础上，在Oracle中，每次提交时，SCN都会推进（SCN只会推进，不会后退）。   

**除非你创建表时支持行级维护ORA_ROWSCN，否则Oracle会在块级维护。**也就是说，默认情况下，一个块上的多行会共享相同的ORA_ROWSCN值。  

		select deptno, dname, 
			   dbms_rowid.rowid_block_number(rowid) blockno,
			   ora_rowscn
		from dept;

重建表，启用行及维护的ORA_ROWSCN。

		create  table dept2 
		rowdependencies  
		as
		select * from dept;

通过启用rowdependencies，再修改行的时候，就会看见只有对应行的ora_rowscn推进了。  

#### 将SCN转换为墙上的时钟时间   
可以把SCN转换为近似的墙上时钟时间（有+/-3秒的偏差）。  

	select deptno, ora_rowscn, scn_to_timestame(ora_rowscn) ts 
	from dept;   

不过，从SCN到墙上时钟时间的这种转换有一些限制：数据库的正常运行时间只有5天左右。  


### 乐观锁定还是悲观锁定  

一般来说，悲观锁定在Oracle中工作的很好，而且与乐观锁定相比，悲观锁定有很多优点。  
不过，悲观锁定需要与数据库一直有有状态的连接，因为无法跨越连接持有锁。真是因为这一点，在当前的许多情况下，悲观锁定不太现实。   
如今对大多数应用来说，我都建议采用乐观并发控制。   


### 阻塞  
如果一个会话持有某个资源的锁，而另一个会话在请求这个资源，就会出现阻塞。这样一来，请求的会话会被阻塞，它会“挂起”，直到持有锁的会话放弃锁定的资源。   

几乎在所有情况下，阻塞都是可以避免的。实际上，如果你真的发现会话在一个交互式应用被阻塞，就说明很可能同时存在另一个bug，即丢失更新。也就是说，你的应用逻辑有问题，这才是阻塞的根源。    

#### 阻塞的insert  
最常见的情况就是，你有一个带主键的表，或者表上有唯一性约束，但有两个会话试图用同样的值插入一行。如果是这样，其中一个会话就会阻塞，直到另一个会话提交或者回滚为止。   
还有一种情况，可能多个表通过引用完整性约束相互链接。对子表的插入可能会阻塞，因为它所依赖的父表正在创建或删除。   

如果应用允许最终用户生成主键/唯一列值，往往就会发生insert阻塞。为了避免这种情况，最容易的办法是使用一个序列来生成主键/唯一列值。  

如果无法使用序列，那你可以使用手工锁来避免这个问题，ijzheli的手工锁是通过内置的DBMS_LOCK报来实现的。详细参考p199    
**注意：dbms_lock权限必须直接授予用户，而不能授予角色，用户无法从角色中继承dbms_lock权限。**   

尽管Oracle有无限多个行级锁，但是enqueue锁（这是一种队列锁）的个数则是有限的。如果在会话中插入大量行，而没有提交，可能会发现创建了太多的enqueue队列锁，而耗尽了系统的队列资源（超出了 enqueue_resources系统参数设置的最大值），因为每行都会创建另一个enqueue锁。  

#### 阻塞的merge、update和delete   

在一个交互应用中，可以从数据库中查询某个数据，允许最终用户处理这个数据，再把它“放回”到数据库，此时如果update或delete阻塞，就说明代码中可能存在一个丢失更新问题。你试图update其他人正在更新的行。    
通过使用select  for update nowait 查询可以避免这个问题，这个查询能做到：  

1. 验证自从你查询数据之后数据未被修改（防止丢失更新）。   
2. 锁住行（防止update或者delelte被阻塞）。  


### 死锁  

如果你有两个会话，每个会话都持有另一个会话想要的资源，此时就会出现死锁（deadlock）。  
死锁示例：    
数据库有两个表A和B，每个表中都只有一行。打开两个会话。在会话A中更新A表，在会话B中更新B表。现在，如果想在会话B中更新A表，就会阻塞，。会话A已经锁定了这一行。这不是死锁，只是阻塞而已。因为会话A还有机会提交或回滚，这样会话B就能继续。  
如果在回到会话A，试图更新表B，这就会导致一个死锁。要在这两个会话中选择一个作为“牺牲品”，让它的语句回滚。  

Oracle极少出现死锁，甚至可以认为是几乎不存在的。   
导致死锁的头号原因是外键未加索引。
第二号原因是表上的位图索引遭到并发更新。  

在以下两种情况下，Oracle在修改父表后会对子表加一个全表锁： 

1. 如果更新了父表的主键，由于外键上没有索引，所以子表会被锁住。  
2. 如果删除了父表中的一行，整个子表也会别锁住。（由于外键上没有索引）。  

**在关系数据库中，更新主键是一个大忌。**   


在以下情况下，未加索引的外键也可能带来问题：  

1. 如果有 on delete cascade，而且没有对子表加索引。   
例如：emp表是dept的子表，delete deptno = 10 应该 级联至emp。如果emp表中deptno没有索引，那么删除dept表中的每一行时，都会对emp做一个全表扫描。这个全表扫描可能是不必要的，而且如果从父表删除多行，父表中没删除一行就要扫描一次子表。    
2. 从父表查询子表。  
再次考虑emp/dept例子。利用deptno查询emp表是相当常见的。如果频繁运行以下查询（例如，生成一个报告），你会发现没有索引会使查询速度变得很慢：  

	select * from dept, emp
	where emp.deptno = dept.deptno 
	and dept.deptno = :x;


什么时候不需要对外键加索引呢？ 

1. 没有从父表删除行。   
2. 没有更新父表的唯一键/主键值。（当心SQL自动生成工具会无意地更新主键）   
3. 没有从父表连接子表（如detp连接到emp）。   
如果满足了上述全部3个条件，那么就完全可以不用对外键加索引。   

### 锁升级  

**Oracle不会升级锁，从来不会。**    
出现锁升级时，系统会降低锁的力粒度。举例来说，数据库系统可以把一个表的100个行锁变成一个表级锁。  

Oracle会尽可能的在最低级别锁定（也就是说，限制最少的锁），如果必要，会把这个锁转换为一个更受限的级别。  
如果用for udpate子句从表中选择一行，就会创建两个锁。一个锁放在所选的行上（这是一个排他锁：任何人都不能以独占模式锁定这个一行）。另一个锁是row share table锁，放在表本身上。这个锁能防止其他会话在表上放置一个排他锁，举例来说，这样能相应的防止这些会话改变表的 结构。  

在Oracle中，1个锁的开销与10000个锁的开销是一样的，都没有开销。   


## 锁类型  

Oracle中主要有3类：

1. DML锁 -- select、insert、update、merge和delete。DML锁机制允许并发执行数据修改。例如DML锁可能是特定数据行上的锁，或者是锁定表中所有行的表级锁。    
2. DDL锁 -- create或alter语句，DDL锁可以保护对象结构定义。   
3. 内部锁和闩 -- Oracle使用这些锁来保护其内部数据结构。闩是Oracle采用的一种轻量级的低级串行化设备，功能上类似于锁。闩是数据库中导致竞争的一个常见原因。轻量级指的是闩的实现，而不是闩的作用。    

### DML锁  

DML锁用于确保一次只有一个人能修改一行。   

#### TX锁（事务锁）   

事务发起的第一个修改时会得到TX锁（事务锁），而且会一直持有这个锁，直至事务执行提交或回滚。  
TX锁用作一种排队机制，使得其他会话可以等待这个事务执行。事务中修改或通过select for update 选择的每一行都会“指向”该事务的一个相关TX锁。   

Oracle中，闩是数据的一属性。Oracle并没有一个传统的锁管理器，不会用锁管理器为系统中锁定的每一行都维护一个长长的列表。   

Oracle中的锁定过程如下:   

1. 找到想锁定的那一行的地址。 
2. 到达那一行。  
3. 锁定这一行（如果这一行已经锁定，则等待锁住他的事务结束，除非使用了nowait选项）。   


由于闩为数据的一个熟悉，Oracle不需要传统的锁管理器。事务只是找到数据，如果数据还没有被锁定，则对其锁定。   
在Oracle对数据行进行锁定时，行指向事务ID的一个副本，事务ID存储在包含数据的块中，释放锁是，事务ID却会保留下来。这个事务ID是事务所独有的，表示了回滚段号、槽和序列号。  
事务ID留在包含数据行的块上，可以告诉其他会话：你“拥有”这个数据（并非所有的数据都是你的，只是你修改的那一行“归你所有”）。另一个会话到来时，它会看到锁ID,由于锁ID表示一个事务，所以可以很快查看到持有这个锁的事务释放还是活动的。如果锁不活动，则允许会话访问这个数据。如果锁还是活动的，会话就会要求一旦释放锁就得到通知。因此，有了一个排队机制：请求的会话会排队，等待目前拥有锁的事务执行，然后得到数据。  

查看会话是否有锁的常用的三个视图:   

1. v$transaction   
2. v$session   
3. v$lock   
在v$lock中，如果某个会话将emp表的一行锁定，v$lock视图中就有对应这个会话的一行来指示这一事实。如果一个会话锁定了emp表职工哦你的数百万行，v$lock视图职工哦你对应这个会话还是只有一行。这个视图显示了各个会话有哪些队列锁。  

v$lock中lmode各个值的含义（request和lmode含义相同）。  

0 -- none  
1 -- null   
2 -- row-S(SS)   
3 -- row-X(SX)  
4 -- share (S)    
5 -- S/Row(SSX)   
6 -- exclusive(X)   

示例：   

	sql>update  dept set deptno = deptno + 10;

	sql>select username,
			   v$lock.sid,
			   trunc(id1/power(2,16)) rbs,
			   bitand(id1,to_number('ffff','xxxx'))+0 slot,
			   id2 seq,
			   lmode,
			   request
		from v$lock, v$session
		where v$lock.type = 'TX'
		and   v$lock.sid = v$session.sid 
		and   v$session.username = USER;

	USERNAME 	SID 	RBS 	SLOT 	SEQ 	LMODE 	REQUEST  
	-----------------------------------------------------------
	LXJ 	    145     4 		12 		16582 	 6 			0

	sql> select xidusn, xidslot, xidsqn 
	 	 from v$transaction;   

	 XIDUSN    		XIDSLOT   		XIDSQN   
	 ---------------------------------------
	     4             12           16582


如何用数据本身来管理锁定和事务信息。这是块开销的一部分。对于锁定了该块中某些数据的各个“实际”事务，在这个事务表中都有一个相应的条目。   
这个结构的大小由创建对象时create语句上的两个物理属性参数决定:   
initrans -- 这个结构初始的预分配大小。对于索引和表，这个大小默认是2。  
maxtrans -- 这个结构可以扩展到的最大大小。默认是255。在实际中，最小值是2。不过从10g开始，这个设置就废弃了。maxtrans总是255。   

默认情况下，每个块最开始都有两个事务槽。一个块上同时活动的事务数受maxtrans值的约束，另外也受块上空间可用性的限制。如果没有足够的空间来扩大这个结构，块就无法得到255个并发事务。   

大多数情况下，initrans的默认值2已经足够了，因为事务表会动态扩大（只要空间允许）。但是在某些环境中，可能需要加大这个设置来提高并发性，并减少等待。比如在频繁修改的表上可能要增加initrans设置，或者更常见的是，对于频繁修改的索引也可能需要这么做。因为索引块中的行一般比表中的多。你可能需要增加pctfreee或者initrans。   


#### TM(DML Enqueue)锁  

TM锁（TM lock）用于确保在修改表的内容时，表的结构不会改变。   
如果你已经更新了一个表，会得到这个表的一个TM锁。这会防止另一个用户在该表上执行drop或者alter命令。    
例如，如果你的表有一个tm锁，而另一个用户试图在这个表上执行ddl，他就会得到以下错误：   

	drop table dept  
	            * 
	error at line 1:
	ORA-00054:resource busy and acquire with nowait specified   


尽管每个事务只能得到一个TX锁，但是TM锁则不同，修改了多少个对象，就能得到多少个TM锁。而且，TM锁的ID1列就是DML锁定对象的对象ID，所以，很容易发现哪个对象持有这个锁。   

	示例：
	sql> create table t1( x int); 

	sql> create table t2( x int);  

	sql> insert into t1 values(1);  

	sql> insert into t2 values(1);  

	sql> select (select username
				 from  v$session 
				 where  sid = v$lock.sid ) username,
				sid,
				id1,
				id2,
				lmode,
				request,block,v$lock.type
		 from v$lock
		 where sid = (select sid
		 	          from   v$mystat
		 	          wher   rownum = 1)

	USERNAME 	SID 	ID1 	ID2 	LMODE 	 REQUEST 	BLOCK 	TYPE  
	----------------------------------------------------------------------
	LXJ 		161 	262151	16584    6          0           0     TX
	LXJ         161		62074	0 	     3 			0          	0     TM
	LXJ      	161		62073	0 		 3          0           0     TM


关于TM锁的一个有意思的地方是：系统中允许的TM锁总数可以由你来配置（有关细节参见Oracle Reference手册中的DML_LOCKS参数定义）。实际上，这个值可以设置为0。但这并不是说你的数据库变成了一个只读数据库（没有锁），而是说不允许DDL。   
在非常专业的应用中（如RAC实现），这一点就很有用，可以减少实例内可能发生的协调次数。   

还可以通过使用 alter table <tablename> disable table lock 命令，还可以逐对象地禁用TM锁。这是一种快捷方法，可以使意外删除表的“难度更大”，因为在删除表之前，你必须重新启用表锁。还能用它来检测由于外键未加索引而导致的全表锁。    


### DDL锁  

在DDL操作中会自动为对象加DDL锁（DDL Lock），从而保护这些对象不会被其他会话锁修改。   
例如，如果我执行一个DDL操作alter table t, 表t上就会加上一个排他DDL锁，以防止其他会话得到这个表的DDL锁或者TM锁。   
在DDL语句执行期间会一直持有DDL锁，一旦操作执行结束后就立即释放DDL锁。   

通常会把DDL语句包含在隐式提交（或提交/回滚对）中来执行这些工作，由于这个原因，在Oracle中DDL一定会提交。每条DDL语句实际上都如下执行：  

	begin
		commit;
		DDL-STATEMENT
		commit;
	exception
		when others then rollback;
	end;

DDL会首先提交，然后再执行对应的DDL语句。因此如果必须回滚，它不会回滚你的事务。如果你执行了DDL，它会使你所执行的所有未执行的工作成为永久性的，即使DDL不成功也是这样。  

如果你需要执行DDL，但是不想它提交你现有的事务，就可以使用一个自治事务。  

有三种类型的DDL锁：   

1. 排他DDL锁 -- 防止其他会话得到他们自己的DDL锁或TM（DML）锁。这说明，在DDL操作期间你可以查询一个表，但是无法以任何方式修改这个表。    
2. 共享DDL锁 -- 这个锁会保护锁引用的对象结构，使之不会被其他会话修改，但是允许修改数据。   
3. 可中断解析锁 -- 这个锁允许一个对象（如共享池中缓存的一个查询计划）向另外某个对象注册其依赖性。如果在被依赖的对象上执行DDL，Oracle会查看已经对该对象注册了依赖性的对象列表，并使这些对象无效。因此，这些锁是“可中断的”，他们不能防止DDL出现。    
譬如基础表修改后，相关的存储过程会变成失效状态。    


在Oracle中，现在有些DDL操作没有DDL锁也可以发生，例如：  
`create index t_idx on t(x) online;`  
online关键字会改变具体建立索引的方法。Oracle并不会加一个排他DDL锁来防止数据修改，而智慧视图得到表上的一个低级（mode 2) TM锁。这会有效防止其他DDL发生，同时还允许DML正常进行。   
Oracle执行这一壮举的做法是，为DDL语句执行期间对表所做的修改维护一个记录，执行create时再把这些修改应用至新的索引。这样能大大增加数据的可用性。   


共享DDL锁示例： 在创建存储的编译对象（如过程和视图）时，会对依赖的对象加这种共享的DDL锁。例如，如果执行以下语句：   

	create view myview
	as
	select * 
	from emp, dept
	where emp.deptno = dept.deptno;  

表emp和dept都会加上共享DDL锁，而create view命令仍在处理。可以修改这些表的内容，但是不能修改他们的结构。   


DBA_DDL_LOCKS视图--该视图没有对应的v$视图，而且默认并不会自动安装。必须手动运行$ORACLE_HOME/rdbms/admin目录下的catblock.sql脚本来安装这个视图以及其他锁视图。必须用sys用户来执行才会成功。   

在这个视图中，owner列不是锁的所有者。而是所锁定对象的所有者。  

这个视图对开发人员很有用，发现测试或开发系统中某段代码无法编译时，将会挂起并最终超时。这说明，有人正在使用这段代码（实际上运行这段代码），你可以使用这个视图来查看这个人是谁。对于grants和对象的其他类型的ddl也是一样。例如，无法对正在运行的过程授予execute权限。可以使用同样的方法来发现潜在的阻塞者和等待者。   


### 闩 

闩是轻量级的串行化设备，用于协调对共享数据结构、对象和文件的多用户访问。   

闩就是一种锁，设计为只保持极短的一段时间（比如，修改一个内存中的数据结构所需的时间）。   
闩用于保护某些内存结构，如数据库块缓存区或共享池中的库缓存。   

闩的分配相当随机，看运气。闩释放后，紧接着不论哪个会话请求闩都会得到它。等待闩的会话不会排队，只是一大堆会话在不断的重试。  

闩只保持很短的时间，而且提供了一种清理机制，万一某个闩持有者持有闩时异常的“死掉了”，就能执行清理。这个清理由PMON执行。   

队列锁在前面已经讨论过，这也是一种更复杂的串行化设备，例如，在更新数据库表中的行时就会使用队列锁。   
与闩的区别在于，队列锁允许请求者“排队”等待资源。对于闩全球，请求者会话会理解得到通知释放得到了闩。而对于队列锁，请求者会话会阻塞，直至真正得到锁。    

队列锁没有闩块。  

#### 闩自旋  

闩是一种锁，锁是串行化设备，而串行化设备会妨碍可扩缩性。   
如果你的目标是构建一个能在Oracle环境中很好的扩缩的应用，就必须寻找好事的方法和解决方案，尽量减少所需执行的闩。   

等待闩可能是一个代价很高的操作。如果闩不是立即可用的，就得等待。在一台多CPU机器上，我们的会话就会自旋（spin），也就是说，在循环中反复尝试来得到闩。出现自旋的原因是，上下文切换的开销很大（上下文切换指被踢出cpu，然后又调度回cpu）。   
如果出现自旋并不断的尝试向得到闩，但是之后还是得不到，此时我们的进程才会睡眠，或者让开CPU，而让其他工作进行。  

得到一个闩的开销不只是“测试和设置”这么简单，我们尝试得到闩时，可能会耗费大量的cpu时间，系统看上去非常忙（因为消耗了很多cpu时间），但是并没有做多少实际工作。   


**使用绑定变量可以大量减少闩的产生**


### 手动锁定和用户定义锁  

#### 手动锁定   

我们可以使用 select ... for update 语句来手动锁定。还可以使用lock table来手动锁定。   
如果你在编写一个大批量的更新，它会影响给定表的大多数行，而且你希望保证没有人能“阻塞”你，你就可以使用lock table in exclusive mode 语句。通过这种方式锁定表，就能确保你的更新能够执行所有的工作，而不会被其他事务锁阻塞。不过，有lock table语句的应用确实很少见。    

#### 创建自己的锁   

通过dbms_lock包，Oracle实际上向开发人员公开了它在内部使用队列锁的机制。   

为什么想要创建自己的锁呢？这通常是与应用有关的。例如你可能需要使用这个包对Oracle外部的一些资源进行串行化访问。假设你在使用utl\_file包，它允许你邪之服务器文件系统上的一个文件。   
由于这个文件是外部的，Oracle不会对试图同时修改这个文件的多个用户进行协调。现在由于有了dbms\_lock包，在你打开、写入和关闭文件之前，可以采用排他模式请求一个锁（以文件命名），一次只能有一个人向这个文件写消息。这样所有人都会排队。通过利用dbms\_lock，等你用完了锁之后能手动的释放这个锁，或者在你提交时自动释放这个锁，甚至可以在你登录期间一直保持这个锁。   





 










